[[intro-reactive]]
== Introduction to Reactive Programming
Reactor is an implementation of the Reactive Programming paradigm, which can be
summed up as:

//TODO find better quote
[quote]
Reactive programming is oriented around data flows and the propagation
of change. This means that the underlying execution model will automatically
propagate changes through the data flow.

In this particular instance, pioneered by the Reactive Extensions (Rx) library
in the .NET ecosystem, and also implemented by RxJava on the JVM, the reactive
aspect is translated in our object-oriented languages as a kind of an extension
of the Observer design pattern.

As time went, a standardization emerged through the *Reactive Streams* effort,
which defines a set of interfaces and interaction rules for reactive libraries
on the JVM.

One can also compare the main reactive streams pattern with the familiar Iterator
design pattern, as there is a duality to the `Iterator`-`Iterable` pair in all
these libraries. One major difference is that while an Iterator is _pull_ based,
reactive streams are *push*-based.

Using an iterator is quite imperative, even though the method of accessing
values is solely the responsibility of the `Iterable`. Indeed, it is up to the
developer to choose when to access the `next()` item in the sequence. In
reactive streams, the equivalent of the above pair is `Subscriber`-`Publisher`.
But it is the `Publisher` that notifies the Subscriber of newly available values
_as they come_, and this push aspect is key to being reactive.

Additionally to pushing values, the error handling and completion aspects are
also covered in a well defined manner, so a `Publisher` can push new values to
its `Subscriber` (calling `onNext`), but also signal an error (calling `onError`
and terminating the sequence) or completion (calling `onComplete` and
terminating the sequence).

[quote]
onNext x 0..N [onError | onComplete]

This approach is very flexible, as the pattern applies indifferently to use
cases where there is at most one value, n values or even an infinite sequence of
values (for instance the ticks of a clock).

But let's step back a bit and reflect on why we would need such an asynchronous
reactive library in the first place.

//TODO flesh out, add more preamble?

=== Blocking is bad
//TODO ok?
=== Asynchronicity to the rescue?
//TODO introduce asynchronous code, solutions on the JVM, why they are hard to write and maintain

=== From Imperative to Reactive Programming
==== Data as a flow
==== Elements of functional style
